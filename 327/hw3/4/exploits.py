import multiprocessing

from vulnerable import withdraw_money
from vulnerable import transfer_funds
from vulnerable import get_user_profile
from vulnerable import Session

USER = "user"
BALANCE_FILE = f"/tmp/{USER}_balance.txt"

def init_balance():
    with open(BALANCE_FILE, "w") as f:
        f.write("1000")  # Initial balance

def do_withdraw():
    withdraw_money(USER, 700)  # Try withdrawing $700 in both processes

def custom_authenticate(username, password):
    return True


if __name__ == "__main__":

#part one
    print("Part One:\n")

    init_balance()

    # Initial balance
    with open(BALANCE_FILE, "r") as f:
        print(f"\n[+] Initial Balance: ${f.read()}\n")

    # Fork two processes to simulate race condition
    p1 = multiprocessing.Process(target=do_withdraw)
    p2 = multiprocessing.Process(target=do_withdraw)

    p1.start()
    p2.start()

    p1.join()
    p2.join()

    # Final balance
    with open(BALANCE_FILE, "r") as f:
        print(f"\n[+] Final Balance: ${f.read()}")

#part two
    print("Part Two:\n")

    # Replace the authenticate function in transfer_funds
    transfer_funds.__globals__['authenticate'] = custom_authenticate

    transfer_funds("alice", "eve",1000)

#part three
    print("Part Three:\n")

    user_data = {"profile": None}
    try:
        # Call the function which will throw an error
        get_user_profile(user_data)
    except AttributeError as e:
        # Catch the AttributeError and handle it here
        print(f"AttributeError:{e}")

#part 4
    print("Part Four\n")

    session = Session("alice")

    print("[+] Username before logout:", session.get_username())

    session.logout()

    try:
        print("[!] Username after logout:", session.get_username())  # UAF trigger
    except AttributeError as e:
        print("[!] Caught exception:", e)

    exit(1)
